<template>
  <div v-if="showLogin">
    <MessageError v-if="graphqlError">{{ graphqlError }}</MessageError>
    <SigninForm @login="loginSuccess" @cancel="cancel" />
  </div>
  <LayoutModal v-else :title="title" :show="true" @close="close()">
    <template v-slot:body>
      <!-- wait until metadata loaded, and in case of update (pkey!=null) also the value -->
      <LayoutForm v-if="tableMetadata && (pkey == null || value)">
        <span v-for="column in columnsWithoutMeta" :key="column.name">
          <!-- in case of 'create' (value == null) only show pkey inputs -->
          <RowFormInput
            v-model="value[column.name]"
            :label="column.name"
            :description="column.description"
            :columnType="column.columnType"
            :table="column.refTable"
            :filter="refLinkFilters[column.name]"
            :refLabel="column.refLabel"
            :refBack="column.refBack"
            :required="column.required"
            :errorMessage="errorPerColumn[column.name]"
            :readonly="column.readonly || (pkey && column.key == 1)"
            :graphqlURL="graphqlURL"
            :refBackType="getRefBackType(column)"
            :pkey="getPkey(value)"
          />
        </span>
      </LayoutForm>
    </template>
    <template v-slot:footer>
      <div class="container-fluid p-0">
        <MessageSuccess v-if="success">{{ success }}</MessageSuccess>
        <MessageError v-if="graphqlError">{{ graphqlError }}</MessageError>
      </div>
      <ButtonAlt @click="close()">Close</ButtonAlt>
      <ButtonOutline v-if="isUpdate" @click="saveDraft">
        Save draft
      </ButtonOutline>
      <ButtonAction v-if="isUpdate" @click="save">
        Save {{ table }}
      </ButtonAction>
      <ButtonAction v-if="!isUpdate" @click="saveEditDraft">
        Create
      </ButtonAction>
    </template>
  </LayoutModal>
</template>

<script>
import LayoutForm from "../layout/LayoutForm.vue";
import LayoutModal from "../layout/LayoutModal.vue";
import MessageError from "../forms/MessageError";
import MessageSuccess from "../forms/MessageSuccess";
import ButtonAction from "../forms/ButtonAction.vue";
import ButtonAlt from "../forms/ButtonAlt.vue";
import ButtonOutline from "../forms/ButtonOutline";
import SigninForm from "../layout/MolgenisSignin";
import TableMixin from "../mixins/TableMixin";
import GraphqlRequestMixin from "../mixins/GraphqlRequestMixin";
import RowFormInput from "./RowFormInput.vue";

export default {
  extends: TableMixin,
  mixins: [GraphqlRequestMixin],
  data: function () {
    return {
      showLogin: false,
      value: {},
      errorPerColumn: {},
      success: null,
    };
  },
  props: {
    /** when updating existing record, this is the primary key value */
    pkey: Object,
    /** (optional) visible columns, useful if you only want to allow partial edit (array of strings) */
    visibleColumns: Array,
    /** (optional) when creating new record, this is initialization value */
    defaultValue: Object,
  },
  components: {
    LayoutForm,
    RowFormInput,
    ButtonAction,
    ButtonAlt,
    LayoutModal,
    MessageError,
    MessageSuccess,
    SigninForm,
    ButtonOutline,
  },
  methods: {
    close() {
      this.$emit("close");
    },
    getRefBackType(column) {
      if (column.columnType === "REFBACK") {
        //get the other table, find the refback column and check its type
        return this.getTable(column.refTable)
          .columns.filter((c) => c.name === column.refBack)
          .map((c) => c.columnType)[0];
      }
    },
    reload() {
      //override superclass
      if (this.pkey) {
        TableMixin.methods.reload.call(this);
      }
    },
    loginSuccess() {
      this.graphqlError = null;
      this.success = null;
      this.showLogin = false;
    },
    saveDraft() {
      this.executeCommand(true);
    },
    saveEditDraft() {
      this.executeCommand(true);
    },
    save() {
      this.executeCommand(false);
    },
    executeCommand(isDraft) {
      this.graphqlError = null;
      this.success = null;
      // todo spinner
      let name = this.table;

      // indicate if draft
      if (isDraft) {
        this.value["mg_draft"] = true;
      } else {
        this.value["mg_draft"] = false;
      }

      let variables = { value: [this.value] };
      let query = `mutation insert($value:[${name}Input]){insert(${name}:$value){message}}`;
      if (this.pkey) {
        query = `mutation update($value:[${name}Input]){update(${name}:$value){message}}`;
      }
      this.requestMultipart(this.graphqlURL, query, variables)
        .then((data) => {
          console.log(JSON.stringify(data));
          console.log(JSON.stringify(data.data.insert));
          if (data.data.insert) {
            console.log("insert");
            this.success = data.data.insert.message;
            this.$emit("update:pkey", this.value);
          }
          if (data.data.update) {
            this.success = data.data.update.message;
          }
        })
        .catch((error) => {
          if (error.status === 403) {
            this.graphqlError =
              "Schema doesn't exist or permission denied. Do you need to Sign In?";
            this.showLogin = true;
          } else if (Array.isArray(error.errors)) {
            this.graphqlError = error.errors[0].message;
          } else {
            this.graphqlError = error;
          }
        });
    },
    eval(expression) {
      try {
        return eval("(function (row) { " + expression + "})")(this.value); // eslint-disable-line
      } catch (e) {
        return "Script error contact admin: " + e.message;
      }
    },
    visible(expression) {
      if (expression) {
        return this.eval(expression);
      } else {
        return true;
      }
    },
    validate() {
      if (this.tableMetadata) {
        this.tableMetadata.columns.forEach((column) => {
          // make really empty if empty
          if (/^\s*$/.test(this.value[column.name])) {
            //this.value[column.name] = null;
          }
          delete this.errorPerColumn[column.name];
          // when required
          if (
            column.required &&
            (this.value[column.name] == null ||
              (typeof this.value[column.name] === "number" &&
                isNaN(this.value[column.name])))
          ) {
            this.errorPerColumn[column.name] = column.name + " is required ";
          } else {
            // when not empty
            // when validation
            if (
              typeof this.value[column.name] !== "undefined" &&
              typeof column.validation !== "undefined"
            ) {
              let value = this.value[column.name]; //used for eval, two lines below
              this.errorPerColumn[column.name] = value; //dummy assign
              this.errorPerColumn[column.name] = this.eval(column.validation);
            } else if (
              column.refLink &&
              this.value[column.name] &&
              this.value[column.refLink] &&
              !JSON.stringify(this.value[column.name]).includes(
                JSON.stringify(this.value[column.refLink])
              )
            ) {
              //reflinks should overlap
              this.errorPerColumn[column.name] =
                "value should match your selection in column '" +
                column.refLink +
                "' ";
            }
          }
        });
      }
    },
  },
  computed: {
    isUpdate() {
      return this.pkey;
    },
    columnsWithoutMeta() {
      return this.tableMetadata.columns.filter(
        (c) =>
          //remove mg_columns
          !c.name.startsWith("mg_") &&
          //only visibleColumns
          (this.visibleColumns == null ||
            this.visibleColumns.includes(c.name)) &&
          //in case of 'insert' only the pkey
          (c.key == 1 || this.pkey) &&
          //apply visible expression
          this.visible(c)
      );
    },
    refLinkFilters() {
      let filter = {};
      if (this.tableMetadata) {
        this.tableMetadata.columns.forEach((c) => {
          if (c.refLink) {
            //get the overlap, should be a key column of [refLink][refTable]
            this.tableMetadata.columns.forEach((c2) => {
              if (c2.name === c.refLink) {
                this.schema.tables.forEach((t) => {
                  if (t.name === c.refTable) {
                    t.columns.forEach((c3) => {
                      if (c3.refTable === c2.refTable) {
                        filter[c.name] = {};
                        filter[c.name][c3.name] = {
                          equals: this.value[c.refLink],
                        };
                      }
                    });
                  }
                });
              }
            });
          }
        });
      }
      return filter;
    },
    //@overide
    graphqlFilter() {
      let result = {};
      if (this.tableMetadata && this.pkey) {
        this.tableMetadata.columns
          .filter((c) => c.key == 1)
          .map((c) => (result[c.name] = { equals: this.pkey[c.name] }));
      }
      return result;
    },
    // override from tableMixin
    title() {
      if (this.pkey) {
        return `edit ${this.table}`;
      } else {
        return `create ${this.table}`;
      }
    },
  },
  watch: {
    data(val) {
      //TODO prevent loading of parent class if no pkey
      if (this.pkey && val && val.length > 0) {
        let data = val[0];
        let defaultValue = {};
        this.tableMetadata.columns.forEach((column) => {
          if (data[column.name]) {
            defaultValue[column.name] = data[column.name];
          }
        });
        this.value = defaultValue;
      }
    },
    // validation happens here
    value: {
      handler() {
        this.validate();
      },
      deep: true,
    },
    tableMetadata: {
      handler() {
        this.validate();
      },
      deep: true,
    },
  },
  created() {
    //pass by value
    if (this.defaultValue) {
      this.value = JSON.parse(JSON.stringify(this.defaultValue));
    }
    this.validate();
  },
};
</script>
